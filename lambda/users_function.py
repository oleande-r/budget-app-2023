"""Handles the event that a `GET: /users` or `POST: /users` request is received.

This either returns all users in the database or creates a new user.
"""

import json
import os

from configparser import ConfigParser
from utils import datatier, auth, api_utils


def lambda_handler(event, context):
    """Returns all users in the database, or creates a new user.

    Args:
        event (dict): A JSON representation of the HTTP request.
        context (lambda context object): Provides information about the invocation,
            function, and runtime environment.

    Returns:
        dict: The success response containing `rows` or `userid` or an error response.
    """
    try:
        print("**STARTING**")
        print("**Lambda: Users**")

        #
        # Setup AWS based on config file.
        #
        config_file = "lambda-config.ini"
        os.environ["AWS_SHARED_CREDENTIALS_FILE"] = config_file

        configur = ConfigParser()
        configur.read(config_file)

        #
        # Configure for RDS access.
        #
        rds_endpoint = configur.get("rds", "endpoint")
        rds_portnum = int(configur.get("rds", "port_number"))
        rds_username = configur.get("rds", "user_name")
        rds_pwd = configur.get("rds", "user_pwd")
        rds_dbname = configur.get("rds", "db_name")
        method = event["httpMethod"]

        #
        # Open connection to the database.
        #
        print("**Opening connection**")
        db_conn = datatier.get_db_conn(
            rds_endpoint, rds_portnum, rds_username, rds_pwd, rds_dbname
        )

        if method == "GET":
            #
            # Retrieve all the users.
            #
            print("**Retrieving data**")
            sql = "SELECT * FROM users ORDER BY userid;"
            rows = datatier.retrieve_all_rows(db_conn, sql)

            for row in rows:
                print(row)

            #
            # Respond in an HTTP-like way, i.e. with a status
            # code and body in JSON format.
            #
            print("**DONE, returning rows**")
            return api_utils.success(200, {"rows": rows})

        if method == "POST":
            #
            # Read the username and password from the event body
            #
            print("**Accessing request body**")

            if "body" not in event:
                return api_utils.error(400, "no body in request")

            body = json.loads(event["body"])

            if "username" not in body or "password" not in body:
                return api_utils.error(400, "missing credentials in body")

            username = body["username"]
            password = body["password"]

            sql = """
            SELECT *
            FROM users
            WHERE username = %s;
            """
            row = datatier.retrieve_one_row(db_conn, sql, [username])

            if row != ():
                return api_utils.error(409, "user already exists")

            password = auth.hash_password(password)
            sql = """
            INSERT INTO users (username, pwdhash)
            VALUES (%s, %s);
            """
            datatier.perform_action(db_conn, sql, [username, password])

            #
            # Grab the userid that was auto-generated by MySQL.
            #
            sql = "SELECT LAST_INSERT_ID();"
            row = datatier.retrieve_one_row(db_conn, sql)
            userid = row[0]

            #
            # Respond in an HTTP-like way, i.e. with a status
            # code and body in JSON format.
            #
            print("**DONE, returning...**")
            return api_utils.success(200, {"userid": userid})

    except Exception as err:
        print("**ERROR**")
        print(str(err))

        return api_utils.error(500, str(err))
